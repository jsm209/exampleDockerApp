package users

import (
	"crypto/md5"
	"encoding/hex"
	"strings"
	"testing"

	"golang.org/x/crypto/bcrypt"
)

//TODO: add tests for the various functions in user.go, as described in the assignment.
//use `go test -cover` to ensure that you are covering all or nearly all of your code paths.

// Tests for the Validate() method:
func TestValidate(t *testing.T) {
	cases := []struct {
		input       NewUser
		expectError bool
		errorReason string
	}{
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, false, "Failed to validate correct new user."},
		{NewUser{
			Email:        "jsm209uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, true, "Failed to validate correctly for invalid emails."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "pass", // password is not at least length 6
			PasswordConf: "pass",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, true, "Failed to validate correctly for passwords less than length 6."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "pass", // passwords don't match
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, true, "Failed to validate correctly for incorrectly matching PasswordConf."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "", // invalid username because it's zero length
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, true, "Failed to validate correctly for zero length usernames."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm 209", // invalid username because it has a space
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, true, "Failed to validate correctly for usernames with a space."},
	}

	for _, c := range cases {
		err := c.input.Validate()
		if (!c.expectError && err != nil) || (c.expectError && err == nil) {
			t.Errorf(c.errorReason)
		}
	}
}

// Tests for the ToUser() method:
func TestToUser(t *testing.T) {
	newUser := NewUser{
		Email:        "JSM209@uw.edu",
		Password:     "password",
		PasswordConf: "password",
		UserName:     "jsm209",
		FirstName:    "Joshua",
		LastName:     "Maza",
	}

	user, _ := newUser.ToUser()

	// Testing password hashes correctly
	err := bcrypt.CompareHashAndPassword(user.PassHash, []byte(newUser.Password))
	if err != nil {
		t.Errorf("Password was not correctly hashed with bcrypt.")
	}

	// Testing the photoURL is correctly generated by
	// trimming down and lowercasing the email, and md5 hashing it.
	// Format the email to md5 hash for gravatar
	email := newUser.Email
	email = strings.TrimSpace(email)
	email = strings.ToLower(email)

	m := md5.New()
	m.Write([]byte(email))
	emailHash := hex.EncodeToString(m.Sum(nil))

	expectedPhotoURL := "https://www.gravatar.com/avatar/" + emailHash

	if expectedPhotoURL != user.PhotoURL {

		t.Errorf("Gravatar photo URL was not correctly generated.")
	}
}

// Tests for the FullName() method:
func TestFullName(t *testing.T) {
	cases := []struct {
		input       User
		output      string
		errorReason string
	}{
		{User{
			FirstName: "Joshua",
			LastName:  "Maza",
		}, "Joshua Maza", "Failed to insert a space between first and last names."},
		{User{
			FirstName: "",
			LastName:  "Maza",
		}, "Maza", "No space should be around the given last name."},
		{User{
			FirstName: "Joshua",
			LastName:  "",
		}, "Joshua", "No space should be around the given first name."},
		{User{
			FirstName: "",
			LastName:  "",
		}, "", "Failed to return an empty name given unset names."},
	}

	for _, c := range cases {
		fullName := c.input.FullName()
		if fullName != c.output {
			t.Errorf(c.errorReason)
		}
	}
}

// Tests for the Authenticate() method
func TestAuthenticate(t *testing.T) {
	cases := []struct {
		input       NewUser
		password    string
		expectError bool
		errorReason string
	}{
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, "password", false, "Failed to correctly authenticate valid password."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, "pass", true, "Incorrectly validated an incorrect password."},
		{NewUser{
			Email:        "jsm209@uw.edu",
			Password:     "password",
			PasswordConf: "password",
			UserName:     "jsm209",
			FirstName:    "Joshua",
			LastName:     "Maza",
		}, "", true, "Incorrectly validated an empty password"},
	}

	for _, c := range cases {
		user, _ := c.input.ToUser()
		err := user.Authenticate(c.password)
		if (!c.expectError && err != nil) || (c.expectError && err == nil) {
			t.Errorf(c.errorReason)
		}
	}
}

// Tests for the ApplyUpdates() method
func TestApplyUpdates(t *testing.T) {
	updates := Updates{
		FirstName: "changed",
		LastName:  "man",
	}

	user := User{
		FirstName: "Joshua",
		LastName:  "Maza",
	}

	user.ApplyUpdates(&updates)

	if user.FirstName != "changed" {
		t.Errorf("Failed to change first name.")
	}

	if user.LastName != "man" {
		t.Errorf("Failed to change last name.")
	}

}
